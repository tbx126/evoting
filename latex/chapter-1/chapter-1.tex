\chapter{Introduction}
\begingroup
\justifying
\setlength{\parindent}{0pt}
\setstretch{1.5}
\setlength{\parskip}{0.5\baselineskip}
\titlespacing{\chapter}{0pt}{0pt}{0pt}
\titlespacing{\section}{0pt}{0pt}{0pt}

Electronic voting promises faster tallies, broader access, and auditable records---advantages that have kept it on the reform agenda for decades. Getting it right, however, has proved harder than the promise suggests. A credible system must simultaneously guarantee ballot secrecy, enforce correct state transitions, expose enough for independent verification, and remain usable for both administrators and voters. These demands pull against each other, and that tension is where most practical deployments run into trouble.

Centralized e-voting platforms handle usability and speed well enough, but they shift the burden of trust onto whoever runs the backend. That operator controls the logs, enforces state transitions, and publishes the tally---and independent verification only goes as far as what they choose to share. When a result is contested, investigation typically stalls at the boundary of privileged access rather than resolving through any publicly verifiable mechanism.

This dissertation takes a different path: a blockchain-based architecture that replaces operator trust with on-chain enforcement and cryptographic guarantees. ElGamal homomorphic encryption, Groth16 zero-knowledge proofs, and commitment-based Merkle inclusion proofs are combined into a single end-to-end pipeline. The aim is not a theoretical sketch but a working system---one that can be compiled, deployed, tested, and independently reviewed.

\section{Problem Statement}

Building a voting system that does not depend on trusted operators means satisfying a set of requirements that do not all point in the same direction:
\begin{itemize}
    \item ballot confidentiality across submission, storage, and counting;
    \item correctness checks on vote formation and tally claims that do not reveal ballot contents;
    \item tamper-evident enforcement of election state transitions;
    \item a voter verification path that requires no disclosure of identity or wallet address.
\end{itemize}

Let $V$ be the number of cast ballots and $N$ the number of candidates. Every accepted ballot must encode exactly one valid choice, the aggregate ciphertexts must yield a consistent tally, and the published result must come with cryptographic evidence that anyone can check independently.

\section{Motivation}

Several practical developments make this combination of techniques worth pursuing. Blockchain ledgers maintain append-only event logs with deterministic execution, removing one class of attack---silent rewrites of election state---that centralized backends remain vulnerable to \cite{nakamoto2008,wood2014}. Modern zk-SNARK systems have reached the point where proof sizes are small and on-chain verification fits within smart-contract budgets \cite{groth2016}. Circuit-friendly hash functions and Merkle structures add post-election inclusion checks that scale to large ballot sets without expensive on-chain storage \cite{poseidon2019,merkle1988}.

Taken together, these tools open up a design space where privacy and verifiability no longer need to be traded off against each other, and neither depends on institutional promises to hold.

\section{Research Objectives}

The work targets five outcomes:
\begin{itemize}
    \item a contract-level state machine enforcing explicit lifecycle transitions on the election;
    \item private ballot submission via one-hot ElGamal encryption on BabyJubJub;
    \item Groth16 proofs checking vote legality and tally correctness on-chain;
    \item an anonymous path to confirm ballot inclusion---just a receipt and a Merkle proof, no identity needed;
    \item an honest look at what the implementation gets right and where it comes up short.
\end{itemize}

\section{Research Questions}

Three questions shape how the implementation is built and assessed:
\begin{itemize}
    \item \textbf{RQ1}: Is it feasible to integrate encrypted one-hot ballots and ZKP-based checks into a browser-to-chain workflow without relying on trusted middleware?
    \item \textbf{RQ2}: Does the resulting pipeline offer stronger verifiability than centralized log-based auditing?
    \item \textbf{RQ3}: Of the target security guarantees, which are fully realized in the current code, and which fall short due to specific engineering gaps?
\end{itemize}

Table \ref{tab:rq-mapping} maps each question to where it is evaluated.

\begin{table}[htbp]
\centering
\small
\caption{Research Question to Validation Mapping}
\label{tab:rq-mapping}
\begin{tabular}{L{2.0cm} L{5.0cm} L{5.8cm}}
\toprule
RQ & Evaluation Focus & Primary Evidence Location \\
\midrule
RQ1 & End-to-end integration feasibility of client crypto, proof generation, and contract verification & Chapter 4 implementation workflow and Chapter 5 scenario validation \\
RQ2 & Comparative verifiability gain over centralized e-voting & Chapter 2 positioning and Chapter 5 security analysis \\
RQ3 & Gap analysis between functional completion and high-assurance completion & Chapter 5 outstanding gaps and Appendix B checklist \\
\bottomrule
\end{tabular}
\end{table}

\section{Scope and Boundaries}

The implemented system targets a single-election deployment model with an administrator-controlled tally key. The solution is designed as a high-confidence prototype and research demonstrator, not a production-national-election platform.

Out-of-scope items include coercion resistance, threshold decryption ceremonies, decentralized governance for election administration, and formal verification of contract bytecode. These are addressed as future work rather than claimed as completed features.

\section{Contributions}

The work produces five concrete outputs:
\begin{itemize}
    \item a cross-stack prototype---Solidity contracts, Circom circuits, browser-side JavaScript proving, and Python cryptographic validation---compiled, deployed, and independently testable;
    \item a vote-submission mechanism binding the Poseidon commitment and ciphertext hash as public proof signals;
    \item a tally pipeline that runs homomorphic aggregation and ZKP3 verification, then publishes a Merkle root derived from on-chain commitments;
    \item a post-election audit path where voters confirm ballot inclusion from a local receipt and an exported bundle, without any address-based lookup;
    \item a requirement-driven gap assessment that names unresolved risks explicitly rather than folding them into general limitations.
\end{itemize}

\section{Dissertation Structure}

Chapter 2 surveys prior work and builds the cryptographic foundations the protocol relies on. Chapter 3 then defines the system model, the protocol flow, and the trust assumptions underlying both. Implementation decisions and module-level behaviour are covered in Chapter 4. Chapter 5 reports evaluation outcomes---performance measurements, requirement traceability, and a risk analysis. Chapter 6 concludes and lays out a prioritized hardening roadmap.

\section{Chapter Summary}

This chapter set out the problem context, pinned down three research questions, and drew the scope boundaries that govern how security claims should be read. The contributions were also stated here; they are validated against implementation and evaluation evidence in later chapters. Chapter 2 positions this work in the broader e-voting and cryptographic literature, then develops the theoretical foundations---Groth16 in particular---that the protocol design in Chapter 3 builds on.

\endgroup
