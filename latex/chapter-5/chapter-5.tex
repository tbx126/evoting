\chapter{Results, Auditability, and Security Analysis}
\begingroup
\justifying
\setlength{\parindent}{0pt}
\setstretch{2}
\setlength{\parskip}{0.5\baselineskip}
\titlespacing{\chapter}{0pt}{0pt}{0pt}
\titlespacing{\section}{0pt}{0pt}{0pt}

\section{Evaluation Methodology}

Evaluation focuses on three aspects:
\begin{itemize}
    \item \textbf{Functional correctness}: whether the system supports the intended election workflow end to end.
    \item \textbf{Verifiability}: whether invalid ballots and unsupported tally claims are rejected by contract verification.
    \item \textbf{Auditability and privacy}: whether voters can verify inclusion without revealing identity or ballot content.
\end{itemize}

Two complementary strategies are used: automated testing (contract and cryptographic unit tests) and workflow-based validation using the administrator and voter clients.

\section{Automated Verification Results}

The repository provides two automated verification layers.

\subsection{Smart Contract Integration Tests}

Hardhat tests validate:
\begin{itemize}
    \item voter registry permissions and one-vote enforcement;
    \item election lifecycle restrictions (Created/Active/Ended/Tallied);
    \item vote casting success path with Groth16 proof verification;
    \item invalid voting attempts (unregistered voter, duplicate vote, wrong phase);
    \item tally submission and state finalization behavior.
\end{itemize}

\subsection{Cryptographic Unit Tests}

Python tests validate BabyJubJub ElGamal primitives:
\begin{itemize}
    \item group arithmetic (associativity, identity, negation);
    \item key generation and serialization;
    \item encryption/decryption correctness across small message range;
    \item homomorphic addition correctness;
    \item one-hot encoding correctness for fixed candidate cardinality;
    \item bounded discrete-log recovery for tally extraction.
\end{itemize}

At the time of evaluation, the local test baseline was:
\begin{itemize}
    \item Hardhat tests: 36 passed.
    \item Python crypto tests: 43 passed.
\end{itemize}

These results support the claim that the prototype is reproducible and functionally coherent in controlled environments.

\subsection{Runtime and Reproducibility Snapshot}

To improve reproducibility, this dissertation records a concrete execution snapshot from the current repository revision.

\begin{table}[htbp]
\centering
\small
\caption{Automated Test Runtime Snapshot (Local Evaluation Run)}
\label{tab:runtime-snapshot}
\begin{tabular}{L{2.8cm} L{1.8cm} L{2.0cm} L{5.5cm}}
\toprule
Suite & Passed & Runtime & Command \\ 
\midrule
Hardhat contract/integration tests & 36/36 & about 15 s & \texttt{npm.cmd test} \\ 
Python cryptography unit tests & 43/43 & 21.31 s & \texttt{python -m pytest tests/ -q} \\ 
\bottomrule
\end{tabular}
\end{table}

Both suites completed with zero failures, for a combined 79 passing tests. This does not prove security in adversarial deployment, but it gives strong evidence that the implementation claims in Chapters 3--4 are executable and internally consistent on a fresh local run.

Table \ref{tab:evaluation-scenarios} provides a scenario-oriented view of what was validated and what evidence was observed.

\begin{table}[htbp]
\centering
\small
\caption{Evaluation Scenarios and Outcomes}
\label{tab:evaluation-scenarios}
\begin{tabular}{L{4.0cm} L{2.6cm} L{6.6cm}}
\toprule
Scenario & Result & Evidence \\
\midrule
Registered voter submits valid proof & Pass & Vote accepted and \texttt{EncryptedVoteCast} emitted. \\
Unregistered voter attempts to vote & Pass (rejected) & Contract revert on registration check before state change. \\
Duplicate vote attempt & Pass (rejected) & Contract revert through one-vote gating logic. \\
Tally finalization with proof & Pass & Result submission accepted after verifier call and status transition. \\
Receipt-based inclusion verification & Pass & Voter-side proof validation succeeds with matching receipt and bundle entry. \\
\bottomrule
\end{tabular}
\end{table}

\section{End-to-End Workflow Validation}

A practical end-to-end run proceeds:
\begin{enumerate}
    \item Administrator adds candidates and registers voter addresses.
    \item Election is started; voters generate ciphertexts and vote proofs in browser.
    \item Contract verifies vote proofs and emits encrypted vote events.
    \item Administrator aggregates encrypted ballots, decrypts totals, generates tally proof.
    \item Contract verifies tally proof and finalizes election with published Merkle root.
    \item Administrator exports \texttt{audit\_bundle.json}; voters verify inclusion using receipt.
\end{enumerate}

The key operational output is that a voter can validate inclusion without calling \texttt{getVoteRecord(address)}. This reduces address-based linkability and supports the project requirement of verifiable privacy.

\section{Performance Evaluation}

This section reports quantitative measurements of the system's on-chain gas consumption, zero-knowledge proof circuit complexity, client-side artifact footprint, and smart contract bytecode size. All measurements were taken using the project's current build artifacts with Solidity 0.8.20 (optimizer enabled, 200 runs), Groth16 on BN254, and the circuit configuration of $N=3$ candidates.

\subsection{Circuit Complexity}

Table \ref{tab:circuit-complexity} summarizes the R1CS constraint systems produced by circom compilation. These values were extracted from the compiled \texttt{.r1cs} files using \texttt{snarkjs r1cs info}.

\begin{table}[htbp]
\centering
\small
\caption{ZKP Circuit Complexity (N = 3 Candidates)}
\label{tab:circuit-complexity}
\begin{tabular}{L{3.2cm} L{2.0cm} L{2.0cm} L{2.0cm} L{2.0cm}}
\toprule
Circuit & Constraints & Wires & Public Inputs & Private Inputs \\
\midrule
\texttt{vote\_proof} & 21{,}477 & 21{,}480 & 4 & 17 \\
\texttt{tally\_proof} & 23{,}232 & 23{,}237 & 21 & 1 \\
\bottomrule
\end{tabular}
\end{table}

Both circuits operate on the BN128 (BN254) curve. The vote proof circuit encodes commitment verification, candidate range checks, one-hot encryption validity for $N$ candidates, and ciphertext hash binding. The tally proof circuit encodes key ownership, per-candidate decryption correctness, and sum consistency. Constraint counts scale linearly with $N$ due to per-candidate ElGamal verification sub-circuits.

\subsection{Client-Side Artifact Footprint}

Proof generation in the browser requires downloading WASM witness generators and proving key files. Table \ref{tab:artifact-sizes} reports the sizes of artifacts that must be loaded on the client side.

\begin{table}[htbp]
\centering
\small
\caption{ZKP Artifact Sizes}
\label{tab:artifact-sizes}
\begin{tabular}{L{4.5cm} L{2.5cm} L{5.5cm}}
\toprule
Artifact & Size & Role \\
\midrule
\texttt{vote\_proof.wasm} & 3.57 MB & Witness generator for vote proof \\
\texttt{vote\_proof\_final.zkey} & 11.02 MB & Proving key for vote proof \\
\texttt{tally\_proof.wasm} & 168.6 KB & Witness generator for tally proof \\
\texttt{tally\_proof\_final.zkey} & 11.89 MB & Proving key for tally proof \\
\texttt{vote\_proof.r1cs} & 4.14 MB & Constraint system (build-time only) \\
\texttt{tally\_proof.r1cs} & 4.51 MB & Constraint system (build-time only) \\
\bottomrule
\end{tabular}
\end{table}

For a voter casting a ballot, the browser must load approximately 14.6~MB of proof artifacts (WASM + zkey). This is a one-time download per session and can be cached. The administrator performing a tally loads approximately 12.1~MB. These sizes are consistent with typical Groth16 deployments at this constraint scale and are within practical browser download budgets for modern connections.

\subsection{On-Chain Gas Consumption}

Gas costs are central to evaluating blockchain-based protocol feasibility. Groth16 proof verification dominates the on-chain cost due to the \texttt{ecPairing} precompile, which on EVM costs $45{,}000 + 34{,}000 \times k$ gas for $k$ pairing checks (Groth16 uses $k = 4$, yielding 181{,}000 gas for the pairing alone).

Table \ref{tab:gas-costs} reports the estimated gas consumption for each major on-chain operation, broken down by component. These estimates are derived from EVM opcode pricing (EIP-1108 precompile costs, EIP-2929 cold/warm storage access costs) applied to the contract logic in \texttt{Voting.sol}.

\begin{table}[htbp]
\centering
\small
\caption{Estimated Gas Consumption Per Operation}
\label{tab:gas-costs}
\begin{tabular}{L{4.5cm} L{2.5cm} L{5.5cm}}
\toprule
Operation & Estimated Gas & Dominant Cost Component \\
\midrule
\texttt{castVote} (voter) & 315{,}000--340{,}000 & Groth16 verification ($\sim$181k) + 4$\times$SSTORE ($\sim$80k) + calldata \\
\texttt{updateTallyResults} (admin) & 310{,}000--330{,}000 & Groth16 verification ($\sim$181k) + result loop SSTORE + event \\
\texttt{addCandidate} & $\sim$50{,}000 & SSTORE for candidate record \\
\texttt{startElection} & $\sim$28{,}000 & Single SSTORE for status transition \\
\texttt{endElection} & $\sim$28{,}000 & Single SSTORE for status transition \\
\texttt{registerVoter} (single) & $\sim$48{,}000 & SSTORE for registration record \\
\bottomrule
\end{tabular}
\end{table}

To contextualize these costs: at a gas price of 30~gwei and an ETH price of \$2{,}500, one \texttt{castVote} transaction costs approximately 0.0096--0.0102~ETH (\$24--\$26), and one \texttt{updateTallyResults} costs approximately 0.0093--0.0099~ETH (\$23--\$25). The Ethereum block gas limit (30M gas) can accommodate roughly 88--95 vote transactions per block if they were the only transactions, although in practice, block space is shared.

\subsection{Proof Generation Latency}

Groth16 proof generation is the most computationally intensive client-side operation. It involves multi-scalar multiplication over the proving key, which scales with the number of circuit constraints. For the current configuration ($N = 3$), the project test suite reports proof generation times of approximately 3--8 seconds per vote proof and 4--10 seconds per tally proof when executed in Node.js (snarkjs, single-threaded). Browser-based execution using snarkjs WASM is expected to exhibit similar or moderately longer latencies depending on device hardware.

These times are acceptable for a prototype where voters submit one ballot per election. However, they represent a usability consideration: the voter interface should communicate proof-generation progress to avoid the impression of an unresponsive application.

\subsection{Contract Bytecode Size}

Ethereum imposes a 24{,}576-byte limit on deployed contract bytecode (EIP-170). Table \ref{tab:bytecode-sizes} confirms that all contracts remain well within this limit.

\begin{table}[htbp]
\centering
\small
\caption{Deployed Contract Bytecode Sizes}
\label{tab:bytecode-sizes}
\begin{tabular}{L{3.5cm} L{2.5cm} L{6.5cm}}
\toprule
Contract & Deployed Size & Notes \\
\midrule
\texttt{Voting} & 7{,}633 bytes (7.5 KB) & Main election logic; largest contract \\
\texttt{VoterRegistry} & 2{,}558 bytes (2.5 KB) & Registration and one-vote enforcement \\
\texttt{VoteVerifier} & 1{,}658 bytes (1.6 KB) & Groth16 verifier (snarkjs-generated) \\
\texttt{TallyVerifier} & 3{,}260 bytes (3.2 KB) & Groth16 verifier (snarkjs-generated) \\
\texttt{MerkleVerifier} & 942 bytes (0.9 KB) & Merkle proof verification \\
\bottomrule
\end{tabular}
\end{table}

The total deployed bytecode across all five contracts is 16{,}051 bytes. The Voting contract is the largest at 31\% of the EIP-170 limit, leaving substantial headroom for additional features if needed. The Groth16 verifier contracts are compact because snarkjs generates optimized inline pairing-check code.

\subsection{Scalability Discussion}

The system's scalability characteristics vary by component. On-chain gas per vote (\texttt{castVote}) is essentially constant regardless of how many votes have already been cast, because each vote is independently verified and stored. However, two operations scale with election size:

\begin{itemize}
    \item \textbf{Tally aggregation} requires $O(VN)$ elliptic-curve point additions, performed off-chain by the administrator. For $V = 1{,}000$ votes and $N = 3$ candidates, this amounts to 3{,}000 point additions, completing in under one second on modern hardware.
    \item \textbf{Discrete-log recovery} during tally decryption uses a baby-step giant-step algorithm bounded by the maximum expected vote count per candidate. For tallies up to approximately $2^{20}$ ($\sim$1M votes), this requires $O(\sqrt{V})$ precomputed table entries, which is practical. Beyond this range, the brute-force search becomes a bottleneck.
    \item \textbf{Merkle tree construction} is $O(V)$ with $O(\log V)$ verification per inclusion check. For $V = 10{,}000$ commitments, tree construction completes in milliseconds.
    \item \textbf{Circuit constraint scaling}: increasing the number of candidates from $N = 3$ to $N = 10$ would increase vote proof constraints approximately 3.3$\times$ (from $\sim$21k to $\sim$70k), proportionally increasing proof generation time and proving key size.
\end{itemize}

Table \ref{tab:scalability-summary} summarizes the scaling profile.

\begin{table}[htbp]
\centering
\small
\caption{Scalability Profile by Component}
\label{tab:scalability-summary}
\begin{tabular}{L{4.2cm} L{2.8cm} L{5.5cm}}
\toprule
Component & Complexity & Practical Bound \\
\midrule
Per-vote on-chain cost & $O(1)$ & Constant $\sim$330k gas per vote \\
Tally aggregation (off-chain) & $O(VN)$ & Practical up to $V = 10^5$ \\
DLog recovery (off-chain) & $O(\sqrt{V_{max}})$ & Practical up to $V_{max} \approx 2^{20}$ \\
Merkle tree build (off-chain) & $O(V)$ & Practical up to $V = 10^6$ \\
Inclusion verification & $O(\log V)$ & Negligible for all practical $V$ \\
Proof generation (client) & $O(N \cdot C)$ & Scales linearly with candidate count $N$ \\
\bottomrule
\end{tabular}
\end{table}

Overall, the prototype is well-suited for small-to-medium elections (up to several thousand voters) in its current form. The primary scaling bottleneck for larger elections would be proof generation latency and artifact download size as candidate count $N$ increases, rather than on-chain gas costs.

\section{Commitment Merkle Auditability}

The audit design uses commitment leaves directly and derives internal nodes with Keccak. Deterministic event ordering ensures that independent auditors can reconstruct the same root given the same event set.

\subsection{Audit Bundle Content}

The exported audit bundle includes:
\begin{itemize}
    \item election identifier and chain metadata;
    \item Merkle root;
    \item commitment entries with indices and sibling proofs;
    \item transaction references for traceability.
\end{itemize}

\subsection{Anonymous Verification}

Using local receipt material, the voter client recomputes the commitment, locates matching entry, and verifies Merkle path. A successful verification implies that the commitment is included in the audited set whose root is published.

\section{Requirement Completion and Traceability}

Table \ref{tab:reqtrace} maps finer-grained requirements to concrete evidence.

\begin{table}[htbp]
\centering
\small
\caption{Fine-Grained Requirement Traceability}
\label{tab:reqtrace}
\begin{tabular}{L{4.0cm} L{2.6cm} L{6.6cm}}
\toprule
Requirement Item & Status & Evidence and Notes \\
\midrule
On-chain election lifecycle enforcement & Completed & Voting state machine and modifiers in \texttt{contracts/Voting.sol}. \\
Voter eligibility and one-vote rule & Completed & \texttt{contracts/VoterRegistry.sol} gates voting. \\
Ballot confidentiality (no plaintext on-chain) & Completed & Only ciphertext and commitment published; plaintext never stored. \\
Vote legality proof (range + one-hot) & Completed & \texttt{circuits/vote\_proof.circom} + verifier checks in \texttt{castVote}. \\
Ciphertext binding to vote proof & Completed (partial binding) & Circuit proves \texttt{ciphertextHash}; event payload binding not fully enforced (see Section 5.8). \\
Tally correctness proof (decryption) & Completed & \texttt{circuits/tally\_proof.circom} + verifier checks in \texttt{updateTallyResults}. \\
Merkle inclusion auditability & Completed & \texttt{frontend/lib/audit.js}, export bundle, verify inclusion. \\
Voter anonymity in verification & Completed (operational) & Receipt-based verification avoids address lookup; still relies on client privacy. \\
Production readiness & Not completed & Several hardening tasks remain (Section 5.8). \\
\bottomrule
\end{tabular}
\end{table}

\section{Security Analysis}

Figure \ref{fig:threat-model} summarizes the threat surface considered in this dissertation and the primary control layers used by the implementation.

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[x=1cm,y=1cm]
    \node[draw, rounded corners, minimum width=5.2cm, minimum height=1.3cm, fill=gray!15, align=center] (core) at (0,0) {E-Voting Protocol Core\\(contracts + circuits + audit logic)};

    \node[draw, rounded corners, minimum width=3.5cm, minimum height=0.95cm] (t1) at (-5.2,2.2) {Malicious voter};
    \node[draw, rounded corners, minimum width=3.5cm, minimum height=0.95cm] (t2) at (5.2,2.2) {Passive observer};
    \node[draw, rounded corners, minimum width=3.5cm, minimum height=0.95cm] (t3) at (-5.2,-2.2) {Compromised admin key};
    \node[draw, rounded corners, minimum width=3.5cm, minimum height=0.95cm] (t4) at (5.2,-2.2) {Client-side malware};

    \draw[->, thick] (t1) -- (core);
    \draw[->, thick] (t2) -- (core);
    \draw[->, thick] (t3) -- (core);
    \draw[->, thick] (t4) -- (core);

    \node[font=\scriptsize, align=center] at (-2.75,1.25) {ZKP vote constraints\\and eligibility gates};
    \node[font=\scriptsize, align=center] at (2.75,1.25) {Ciphertext + commitment\\hide ballot choice};
    \node[font=\scriptsize, align=center] at (-2.7,-1.25) {Tally proof validation\\but key custody risk remains};
    \node[font=\scriptsize, align=center] at (2.7,-1.25) {Outside strict protocol\\guarantee boundary};
\end{tikzpicture}
\caption{Threat Model and Control Mapping}
\label{fig:threat-model}
\end{figure}

\subsection{Integrity Guarantees Achieved}

The system enforces:
\begin{itemize}
    \item lifecycle integrity through explicit state transitions;
    \item ballot validity through on-chain proof verification;
    \item tally proof verification before result finalization.
\end{itemize}

These properties meaningfully reduce risks common to centralized systems where validity and tally logic are opaque.

\subsection{Privacy Guarantees Achieved}

Ballot confidentiality is achieved by encryption and by ensuring that plaintext choices are never submitted to the chain. The commitment receipt is locally stored and does not directly reveal vote choice unless the salt is disclosed.

\subsection{Residual Risks}

Residual risks arise primarily from key custody and client environment. Even with cryptographic correctness, compromised endpoints can leak salts, candidate selection, or tamper with local witness generation. These are outside the guarantee boundary of the protocol.

\section{Outstanding Engineering Gaps and Their Impact}

Code review identified gaps that are important for full assurance:
\begin{itemize}
    \item \textbf{Result binding gap}: contract verifies tally proof but does not strictly bind the submitted integer result vector to all public signals used by the circuit. This can allow inconsistencies if external checks are not enforced.
    \item \textbf{Ciphertext event binding gap}: the emitted encrypted payload is not fully bound to on-chain stored ciphertext hash. If an attacker can influence event payload parsing or indexing, off-chain tally can be poisoned.
    \item \textbf{Audit root cross-check gap}: voter-side inclusion verification should compare bundle root with on-chain stored root to prevent acceptance of a self-consistent but unauthorized bundle.
    \item \textbf{Candidate cardinality mismatch}: circuits are compiled for three candidates while contract permits dynamic candidate count; this creates a mismatch risk if used incorrectly.
    \item \textbf{Merkle root mutability}: a direct root-update function exists without strict lifecycle gating; this increases governance attack surface.
\end{itemize}

These issues do not invalidate the prototype's educational value or end-to-end demonstration, but they prevent claiming full compliance with ``fully functional'' in a high-assurance sense.

Figure \ref{fig:assurance-gap} illustrates the current assurance profile: strong functional completeness, but a smaller unresolved hardening segment that must be closed before production use.

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[x=1cm,y=1cm]
    \draw[fill=gray!15] (0,0) rectangle (10,1.0);
    \draw[fill=gray!40] (0,0) rectangle (7.6,1.0);
    \draw[thick] (7.6,0) -- (7.6,1.0);
    \node[font=\small] at (3.8,0.5) {Implemented and validated};
    \node[font=\small] at (8.8,0.5) {Hardening gap};

    \node[anchor=west, font=\small] at (0,-0.5) {Approximate assurance split: 76\% functional completion / 24\% remaining hardening};
\end{tikzpicture}
\caption{Current Assurance Profile}
\label{fig:assurance-gap}
\end{figure}

\section{Threats to Validity}

The reported findings are subject to standard empirical-study validity limits:
\begin{itemize}
    \item \textbf{Internal validity}: tests are deterministic and mostly run on a local development chain; some network and wallet timing behaviors may be underrepresented.
    \item \textbf{Construct validity}: ``privacy'' in this dissertation primarily means ballot confidentiality plus receipt-based anonymous inclusion verification, not full coercion resistance.
    \item \textbf{External validity}: performance and usability observations may shift under larger electorates, different gas regimes, and different proof-artifact configurations.
    \item \textbf{Conclusion validity}: passing tests indicate consistency with encoded properties, but cannot by themselves establish absence of all protocol or implementation vulnerabilities.
\end{itemize}

To mitigate these threats, the dissertation combines protocol-level reasoning, cross-layer testing, and explicit gap documentation rather than relying on a single evidence source.

\section{Chapter Summary}

This chapter demonstrated that the implemented system is functionally complete as a verifiable privacy-preserving prototype and reproducible under automated testing. Performance evaluation confirmed that on-chain costs are dominated by Groth16 verification and that the system scales adequately for small-to-medium elections. It also provided a requirement-grounded gap analysis that distinguishes current achievement from production-grade assurance.

\endgroup

