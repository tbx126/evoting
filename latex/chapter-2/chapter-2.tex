\chapter{Literature Review}
\begingroup
\justifying
\setlength{\parindent}{0pt}
\setstretch{1.5}
\setlength{\parskip}{0.5\baselineskip}
\titlespacing{\chapter}{0pt}{0pt}{0pt}
\titlespacing{\section}{0pt}{0pt}{0pt}

\section{Security Requirements of E-Voting}

A credible e-voting system must satisfy at least four properties: eligibility control, ballot secrecy, integrity of counting, and auditability. Classical protocol literature adds finer distinctions---individual verifiability (a voter confirms their own ballot was counted), universal verifiability (any observer can check tally consistency), and receipt-freeness or coercion resistance \cite{benaloh1994,chaum2004,juels2005}.

In practice, these requirements split across cryptographic and operational controls. Cryptography can confirm that certain relations hold. It cannot, however, guarantee endpoint security, key governance, or anti-coercion behaviour in an uncontrolled environment. That gap matters when reading claims of ``secure voting''.

\section{Centralized E-Voting Systems}

Conventional centralized architectures handle the election lifecycle through web services and database transactions. Mature tooling and low operational complexity give these systems a practical edge; incident response also stays inside one trust boundary. The limitations are harder to overlook:
\begin{itemize}
    \item privileged insiders can alter records or logs if access controls slip;
    \item replaying state transitions independently requires a full data export, which is not always available;
    \item dispute resolution falls back on institutional trust rather than any verifiable record.
\end{itemize}

These gaps motivate replacing trust-in-operator with trust-in-protocol.

\section{Blockchain-Based Voting Approaches}

Blockchain infrastructures maintain immutable append-only logs with deterministic execution rules \cite{nakamoto2008,wood2014}. Election state transitions and event traces are transparently recorded. Smart contracts enforce lifecycle invariants directly---there is no hidden backend to trust.

Transparency cuts both ways, though. If vote semantics appear in plaintext, confidentiality is permanently lost. A privacy-preserving blockchain voting system must therefore pair ledger transparency for control flow with cryptographic concealment for ballot content.

\section{Homomorphic Encryption for Private Tally}

ElGamal encryption on discrete-log groups supports additive homomorphism over encoded messages \cite{elgamal1985}. Each ballot is encoded as a one-hot vector; component-wise aggregation of ciphertexts gives encrypted candidate totals. Decrypting only the aggregates avoids exposing individual ballots.

Two practical advantages follow. Tallying cost scales linearly with vote count using simple point operations. Privacy holds as long as secret-key exposure and plaintext side channels stay controlled---a weaker guarantee than threshold decryption, but achievable without ceremony infrastructure.

\section{Zero-Knowledge Proofs in Voting}

A zero-knowledge proof (ZKP) is a cryptographic protocol in which a prover convinces a verifier that a statement is true without disclosing any information beyond the statement's truth itself \cite{goldwasser1989}. In e-voting, this capability is foundational: a voter must prove that their ballot is correctly formed---encoding exactly one valid candidate choice---without revealing which candidate was selected; an administrator must prove that a tally is correctly decrypted without revealing the secret key. ZKPs therefore allow public verifiability and ballot privacy to coexist.

This dissertation uses Groth16, a zk-SNARK (Succinct Non-interactive ARgument of Knowledge), because its on-chain verification cost is fixed regardless of circuit complexity and proof size is constant at three elliptic-curve points \cite{groth2016}. Circom and snarkjs provide the implementation pipeline from circuit specification to deployable Solidity verifier contracts \cite{circomdocs,snarkjs}.

\subsection{The Problem ZKPs Address}

Classical proof systems require the witness (secret data) to be transmitted to the verifier. In e-voting this is unacceptable: revealing a candidate index to prove ballot validity destroys ballot secrecy; revealing a decryption key to prove tally correctness collapses key governance.

ZKPs separate the \emph{claim} from the \emph{evidence}. Let $x$ be a public statement and $w$ be a private witness. Define a relation $\mathcal{R}$ such that $(x, w) \in \mathcal{R}$ means ``$w$ is a valid witness for $x$''. A ZKP system allows a prover who knows $w$ to produce a short artifact $\pi$ that convinces any verifier that $(x, w) \in \mathcal{R}$, without $\pi$ leaking any information about $w$.

In this project, two instances of this pattern apply:
\begin{itemize}
    \item \textbf{Vote proof}: the public statement and witness are
    \begin{gather*}
    x = (\mathit{commitment},\; H_{ct},\; pk_X,\; pk_Y) \\
    w = (\mathit{candidateId},\; \mathit{salt},\; r_0, \dots, r_{N-1})
    \end{gather*}
    The relation $\mathcal{R}$ requires that the commitment is correctly formed from the candidate index and salt, and that the ciphertexts encode the corresponding one-hot vector under the public key.
    \item \textbf{Tally proof}: $w = sk$, with public statement
    \begin{equation*}
        \begin{split}
        x = (&pk_X,\; pk_Y,\; \bar{C1}^{X}_0,\; \bar{C1}^{Y}_0,\; \dots,\; \bar{C2}^{X}_{N-1},\; \bar{C2}^{Y}_{N-1},\\
             &R^{X}_0,\; R^{Y}_0,\; \dots,\; R^{X}_{N-1},\; R^{Y}_{N-1},\; V)
        \end{split}
    \end{equation*}
    where $R^{X}_j$, $R^{Y}_j$ are the coordinates of the result point $\mathbf{results}[j] \cdot G$ for candidate $j$.
\end{itemize}

\subsection{Formal Security Properties}

A ZKP system must satisfy three properties \cite{goldwasser1989}:
\begin{enumerate}
    \item \textbf{Completeness}: If $(x, w) \in \mathcal{R}$, then an honest prover holding $w$ always produces a proof $\pi$ that the verifier accepts. This guarantees that valid ballots and correct tallies are never falsely rejected.
    \item \textbf{Soundness}: If no valid witness $w$ exists for statement $x$, then no computationally bounded adversary can produce an accepted proof except with negligible probability. This prevents fabricated ballots or incorrect tally claims from being accepted on-chain.
    \item \textbf{Zero-Knowledge}: A simulator can produce proofs indistinguishable from real proofs without knowing $w$. This formalizes that $\pi$ reveals nothing about $w$ beyond the existence of a valid witness.
\end{enumerate}

In a zk-SNARK, soundness is computational (relying on cryptographic hardness assumptions), and the non-interactive property replaces the verifier's challenge with a structured reference string derived from a trusted setup.

\subsection{Arithmetic Circuits and R1CS}

Any computation over a finite field $\mathbb{F}_p$ can be expressed as an arithmetic circuit of addition and multiplication gates. A circuit is \emph{satisfiable} if there exists an assignment to all wires (public inputs, private witnesses, and intermediate values) that makes every gate equation hold. This satisfiability problem is encoded as a \emph{Rank-1 Constraint System} (R1CS).

An R1CS consists of $m$ constraints over a witness vector $\mathbf{s} \in \mathbb{F}_p^n$ (which includes public inputs, private witnesses, and intermediate wire values, with $s_0 = 1$ by convention):
\begin{equation}
    \langle \mathbf{a}_i,\, \mathbf{s} \rangle \;\cdot\; \langle \mathbf{b}_i,\, \mathbf{s} \rangle \;=\; \langle \mathbf{c}_i,\, \mathbf{s} \rangle, \qquad i = 1, \dots, m
\end{equation}
where $\mathbf{a}_i, \mathbf{b}_i, \mathbf{c}_i \in \mathbb{F}_p^n$ are sparse selector vectors derived from the circuit topology. Each multiplication gate contributes one constraint; additions and constant multiplications are absorbed into the selector vectors at no constraint cost.

In circom, the programmer writes constraints in a domain-specific language. The compiler translates them to an \texttt{.r1cs} file (the constraint matrices $A, B, C$) and a WASM witness generator. For this project, the compiled constraint counts are:
\begin{itemize}
    \item \texttt{vote\_proof}: 14{,}590 constraints, encoding commitment verification, candidate range checks, one-hot encryption validity, and ciphertext hash binding.
    \item \texttt{tally\_proof}: 16{,}786 constraints, encoding key-ownership verification, per-candidate decryption correctness, and total-vote sum consistency.
\end{itemize}

\subsection{QAP Transformation}

Groth16 operates on a polynomial encoding of the R1CS called a \emph{Quadratic Arithmetic Program} (QAP) \cite{gennaro2013}. For each constraint index $i$ and witness index $j$, define polynomials $u_j, v_j, w_j \in \mathbb{F}_p[X]$ by Lagrange interpolation through the point values $u_j(i) = a_{i,j}$, $v_j(i) = b_{i,j}$, $w_j(i) = c_{i,j}$.

The witness $\mathbf{s}$ satisfies all $m$ R1CS constraints if and only if the vanishing polynomial $T(X) = \prod_{i=1}^{m}(X - i)$ divides the polynomial:
\begin{equation}
\begin{split}
    P(X) \;=\; &\Bigl(\sum_j s_j\, u_j(X)\Bigr) \cdot \Bigl(\sum_j s_j\, v_j(X)\Bigr) \\
               &-\; \sum_j s_j\, w_j(X)
\end{split}
\end{equation}

Equivalently, there exists a quotient polynomial $H(X)$ such that:
\begin{equation}
    A(X) \cdot B(X) \;-\; C(X) \;=\; H(X) \cdot T(X)
\end{equation}
where $A, B, C$ are shorthand for the left, right, and output linear combinations of the witness polynomials. The prover's task is to commit to all polynomials evaluated at a secret point $\tau$, without knowing $\tau$ in the clear. This is achieved through the structured reference string produced in the trusted setup phase.

\subsection{The Groth16 Protocol}

Groth16 implements the QAP argument using bilinear pairings over elliptic curves. Let $\mathbb{G}_1, \mathbb{G}_2$ be groups of prime order $p$ with generators $G_1, G_2$, and let $e: \mathbb{G}_1 \times \mathbb{G}_2 \rightarrow \mathbb{G}_T$ be a non-degenerate bilinear pairing. The protocol has three phases.

\paragraph{Setup.}
A trusted party samples secrets $(\tau, \alpha, \beta, \gamma, \delta) \overset{\$}{\leftarrow} \mathbb{F}_p^5$ and computes two structured reference strings:
\begin{itemize}
    \item \textbf{Proving key} $\mathit{pk}$: contains $\{[\tau^i]_1\}$ for required powers, $\{[u_j(\tau)]_1\}$, $\{[v_j(\tau)]_2\}$, and blinded combinations---tens of thousands of elliptic-curve points for circuits of this scale.
    \item \textbf{Verification key} $\mathit{vk}$: contains $[\alpha]_1$, $[\beta]_2$, $[\gamma]_2$, $[\delta]_2$, and $\{[(\beta u_j + \alpha v_j + w_j)(\tau)/\gamma]_1\}$ for the public signal indices.
\end{itemize}

The secrets $(\tau, \alpha, \beta, \gamma, \delta)$ are then irrecoverably destroyed---these are the ``toxic waste'' of the trusted setup. If any value were leaked, an adversary could forge proofs for false statements without possessing a valid witness. This risk motivates the \emph{Powers of Tau} multi-party computation ceremony, in which many independent participants each contribute fresh randomness and prove they discarded their contribution. The final artifact is secure as long as at least one participant acted honestly.

\paragraph{Prove.}
Given the full witness $\mathbf{s}$ and the proving key, the prover samples random blinding scalars $r, s' \overset{\$}{\leftarrow} \mathbb{F}_p$ and computes a three-element proof $\pi = (\pi_A, \pi_B, \pi_C)$:
\begin{align}
    \pi_A &= \bigl[\alpha + A(\tau) + r\delta\bigr]_1 \\
    \pi_B &= \bigl[\beta + B(\tau) + s'\delta\bigr]_2 \\
    \pi_C &= \left[\frac{C_{\mathit{priv}}(\tau) + H(\tau)T(\tau)}{\delta}\right]_1 + s' \cdot \pi_A \\
          &\quad + r \cdot \bigl[\beta + B(\tau) + s'\delta\bigr]_1 - rs' \cdot [\delta]_1 \notag
\end{align}
where $[\cdot]_k$ denotes the elliptic-curve point $(\cdot) \cdot G_k$, and $C_{\mathit{priv}}$ denotes the private-witness portion of the $C$ polynomial. The blinding factors $r$ and $s'$ randomize the proof so that different proofs for the same statement are computationally indistinguishable, enforcing the zero-knowledge property.

\paragraph{Verify.}
The verifier checks a single bilinear pairing equation over the four group elements:
\begin{equation}
    e(\pi_A,\; \pi_B) \;=\; e\bigl([\alpha]_1,\; [\beta]_2\bigr) \;\cdot\; e\!\left(\sum_{i=0}^{l} a_i \cdot \mathit{vk}_i,\; [\gamma]_2\right) \;\cdot\; e(\pi_C,\; [\delta]_2)
\end{equation}
where $l$ is the number of public inputs, $a_i$ are their values, and $\mathit{vk}_i = [(\beta u_i + \alpha v_i + w_i)(\tau)/\gamma]_1$ are precomputed elements of the verification key. This single equation encodes the correctness of $A(\tau) \cdot B(\tau) = C(\tau) + H(\tau) \cdot T(\tau)$ through the algebraic properties of the pairing, without recomputing the polynomials at $\tau$. A proof is accepted if and only if this equation holds.

\subsection{On-Chain Verification Cost}

The BN254 curve (also called BN128) is natively supported by the EVM as a precompiled contract at address \texttt{0x08} for pairing computations. Under EIP-1108, the gas cost model is:
\begin{equation}
    \mathit{gas}_{\mathit{pairing}} = 45{,}000 + 34{,}000 \times k
\end{equation}
where $k$ is the number of pairing pairs. The Groth16 verification equation requires $k = 4$ pairs (corresponding to the four terms in the equation above), yielding $45{,}000 + 34{,}000 \times 4 = 181{,}000$ gas for the pairing check alone. Crucially, this cost is \emph{independent of the number of circuit constraints}: a 14{,}590-constraint vote circuit and a 100{,}000-constraint circuit incur identical on-chain verification gas. This property makes Groth16 uniquely suited for complex ZKP computations that must be verified on-chain.

\subsection{Implementation Pipeline}

The implementation follows a four-stage workflow:
\begin{enumerate}
    \item \textbf{Circuit specification}: constraints are written in circom using library templates for BabyJubJub arithmetic, Poseidon hashing, and conditional logic. The compiler outputs \texttt{.r1cs} (constraint matrices $A, B, C$) and a WASM witness generator.
    \item \textbf{Trusted setup}: the Powers of Tau artifact (\texttt{pot16\_final.ptau}) provides a universal SRS supporting up to $2^{16}$ constraints. Circuit-specific phase-2 setup uses snarkjs to specialize the SRS to the particular R1CS, producing the proving key (\texttt{.zkey} file, several megabytes per circuit).
    \item \textbf{Proof generation}: given public inputs and private witnesses, the WASM generator constructs the full witness vector $\mathbf{s}$; snarkjs then computes $(\pi_A, \pi_B, \pi_C)$ using the proving key. In this project, this step executes in the browser using snarkjs with WASM, taking approximately 3--8 seconds for the vote circuit.
    \item \textbf{Verifier export}: snarkjs generates a Solidity contract that hard-codes the verification key and implements the pairing-check equation as direct EVM precompile calls, eliminating runtime parsing overhead.
\end{enumerate}

A key trust property of this pipeline is that the \emph{circuit code is public}: anyone can read \texttt{vote\_proof.circom} and \texttt{tally\_proof.circom}, recompile them, and verify that the resulting R1CS matches the published \texttt{.zkey} artifacts. This auditability---combined with the verifiable Powers of Tau ceremony transcript---means that trust in the system rests on the cryptographic hardness assumptions and the setup ceremony, not on the circuit author's integrity.

\subsection{ZKP Role in This Dissertation}

Three distinct proof instances are deployed, organized into two circuit files:
\begin{enumerate}
    \item \textbf{ZKP1 (commitment correctness)}: proves $\mathit{commitment} = \mathsf{Poseidon}(\mathit{candidateId}, \mathit{salt})$ without revealing $\mathit{candidateId}$ or $\mathit{salt}$.
    \item \textbf{ZKP2 (one-hot validity)}: proves that the submitted ElGamal ciphertexts encrypt precisely the one-hot vector $\mathbf{m}$ consistent with the committed candidate, without revealing $\mathbf{m}$ or the per-component randomness. Because ZKP1 and ZKP2 share witness variables (both depend on $\mathit{candidateId}$), they are compiled into a single \texttt{vote\_proof} circuit. A single proof simultaneously establishes both properties.
    \item \textbf{ZKP3 (tally decryption correctness)}: proves that for each candidate $j$, the published result point $\mathbf{results}[j] \cdot G$ equals the point obtained by decrypting the aggregated ciphertext under $sk$, and that $sk$ is consistent with the public key $PK = sk \cdot G$. The integer vote counts are derived off-chain from these curve points via discrete-log recovery, and are submitted to the contract separately; the circuit proves the correctness of the curve-point representations, not the integer values directly. This circuit is necessarily separate because it operates over the aggregated ciphertext state, which is only defined after all votes have been collected.
\end{enumerate}

The on-chain verifier contracts (\texttt{VoteVerifier.sol}, \texttt{TallyVerifier.sol}), generated automatically by snarkjs, each implement the pairing-check equation as a pure Solidity function. The main \texttt{Voting} contract calls these verifiers as a mandatory precondition for \texttt{castVote} and \texttt{updateTallyResults} respectively, ensuring that no invalid ballot or fabricated tally claim can be committed to the blockchain.

\section{Commitments, Hashing, and Merkle Auditability}

Commitments provide a compact way to bind secret ballot metadata (candidate ID and salt) to a public value. Poseidon is selected as the commitment hash due to circuit efficiency \cite{poseidon2019}. For scalable auditability, commitments are organized into a Merkle tree, and inclusion is verified by logarithmic-size proofs \cite{merkle1988}.

This structure supports a useful operational pattern: a voter can validate that their commitment appears in the audited set without revealing identity, and any third party can recompute the root from published entries if ordering rules are deterministic.

\section{Positioning of This Work}

Relative to prior studies, this project emphasizes implementation-level integration rather than only protocol specification. The dissertation focuses on the full engineering chain from browser-side proof generation to contract-level verification and post-election audit tooling.

The contribution is therefore twofold:
\begin{itemize}
    \item a functional prototype that demonstrates these techniques working together;
    \item a transparent assessment of which security goals are complete, partially complete, or still open.
\end{itemize}

Table \ref{tab:approach-comparison} summarizes the most relevant architectural tradeoffs for this dissertation.

\begin{table}[htbp]
\centering
\small
\caption{Architectural Comparison Across Voting Approaches}
\label{tab:approach-comparison}
\begin{tabular}{L{3.0cm} L{2.9cm} L{2.9cm} L{3.9cm}}
\toprule
Criterion & Centralized E-Voting & Blockchain-Only Voting & This Work (Blockchain + HE + ZKP + Merkle) \\
\midrule
State transparency & Limited by operator logs & High for on-chain actions & High for control flow and published commitments \\
Ballot confidentiality & Depends on backend policy & Usually weak if plaintext on-chain & Stronger via encrypted ballots and commitment receipts \\
Tally verifiability & Operational trust heavy & Moderate unless cryptographic proofs added & High through explicit vote/tally proofs \\
Voter-side inclusion check & Rare or account-linked & Possible but privacy-sensitive & Receipt-based anonymous Merkle inclusion workflow \\
Operational complexity & Lower & Moderate & Higher, but with stronger assurance properties \\
\bottomrule
\end{tabular}
\end{table}

\section{Chapter Summary}

This chapter positioned the dissertation against prior e-voting approaches and clarified why combining blockchain transparency with privacy-preserving cryptography is necessary. The review also identified the central design tradeoff: increased implementation complexity in exchange for stronger verifiability and integrity guarantees.

\endgroup
